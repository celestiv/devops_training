# Node.js + Docker
В этом практическом занятии мы шаг за шагом научимся контейнеризовать веб-приложения Node.js, начиная с простого Dockerfile, разбираясь в подводных камнях и небезопасных местах каждой инструкции Dockerfile.
Это довольно подробное руководство, так как с приложениями на Node.js часто приходится работать в Neoflex. И именно Node.js обещали на хакатоне в конце этого курса. Поэтому разберёмся подробнее.
## Простой образ Node.js Docker
Вот основные инструкции Dockerfile для создания образов Node.js:
FROM node
WORKDIR /usr/src/app
COPY . /usr/src/app
RUN npm install
CMD "npm" "start"
Достаточно скопировать это в файл с именем Dockerfile, затем собрать и запустить его.
$ docker build . -t nodejs-tutorial
$ docker run -p 3000:3000 nodejs-tutorial
Это просто, и это работает, но есть проблема. Это Dockerfile полон ошибок и плохих практик. Избегайте вышеперечисленного всеми способами.
Давайте начнем улучшать этот Dockerfile, чтобы мы могли создавать оптимизированные веб-приложения Node.js с помощью Docker.
Рассмотрим 10 рекомендаций по созданию оптимизированных веб-приложений Node.js с помощью Docker:
Явно указывайте теги базовых образов Docker.
Устанавливайте только prod зависимости в образ Docker Node.js.
Оптимизируйте инструменты Node.js для prod.
Не запускайте контейнеры от имени root.
Безопасно завершайте веб-приложения Node.js в контейнере.
Используйте многоэтапную сборку.
Исключите ненужные файлы при помощи .dockerignore
##  Явно указывайте теги базовых образов Docker.
Можно просто написать в Докерфайле инструкцию FROM node, но что на самом деле будет использовано? У образов Docker всегда есть тэг, и если вы не указываете тег, то по умолчанию используется тег :latest.
Итак, фактически, написав FROM node в вашем Dockerfile, вы всегда будете загружать последнюю версию образа node, то есть, последнюю загруженную на Docker Hub.
Какие проблемы тогда возникают?
- Следующая версия образа node может быть несовместима с предыдущей, или в ней могут быть добавлены новые баги, из-за которых ваше приложение перестанет работать. Это нас не подходит. Мы хотели бы получать более предсказуемое и стабильное поведение нашей программы.
- Образ node:latest основан на полноценной операционной системе, полной библиотек и инструментов, которые могут вам понадобиться или не понадобиться для запуска вашего веб-приложения Node.js. Это значит, что результат нашей работы будет весить больше и работать медленнее. К тому же, в каждом из инструментов могут быть свои уязвимости. Чем больше лишних инструментов в вашем образе, том больше уязвимостей они с собой приносят.

На самом деле, по информации от hub.docker.com образ node довольно большой и включает в себя уязвимостей безопасности. Если вы его используете, то по умолчанию вашей отправной точкой будут 82 уязвимости с низкой опасностью, 3 уязвимости средней опасности и 380 МБ веса образа, в котором ещё нет приложения.
## Best Practice по созданию образов Docker:
- Используйте небольшие образы Docker — это приведет к меньшему объему программного обеспечения в вашем образе, меньше уязвимостей безопасности, и к меньшему размеру, что ускорит процесс сборки образа.
- Ещё можно использовать дайджест образа Docker вместо его имени и тэга. Он представляет собой статический хеш SHA256 образа. Так вы получите предсказуемые сборки образов Docker.
Какие есть рекомендации по выбору базового образа? Если нужен быстрый ответ, то используйте:

`FROM node:20.3.1-bookworm-slim`

## Разбираемся с версиями
Слово slim означает, что из образа исключены лишние инструменты. В большинстве случаев они не нужны. При необходимости их можно установить во время сборки.
Слово bookworm означает версию Debian, на основе которой построен этот образ. Это самая свежая версия, у которой долгосрочная поддержка (Long Term Support) оканчивается в июне 2028 года. Проверить можно, например, тут.
Цифры 20.3.1 означают версию Node. Поддержка версии 20 окончится в апреле 2026 года. Проверить это можно, например, здесь. Лучше брать версию, которая начинается на чётное число. Нечётные версии не получают долговременной поддержки.

У образа node:20.3.1-bookworm-slim меньше уязвимостей, чем у node:latest (1 средне опасных + 17 низко опасных). И он весит 76.13 MB против 380 МБ у node:latest.
Вы можете поискать и другую версию исходного образа, подходящую именно вам. Например, часто рекомендуют использовать FROM node:alpine. Он имеет меньший размер, однако он существенно отличается по другим характеристикам. Но разберёмся, есть ли у него недостатки.

- Что такое Node Alpine?

Node.js Alpine — это неофициальная сборка образа Docker, поддерживаемая командой Node.js Docker. Этот образ включает в себя операционную систему Alpine, которая использует минимальный программный инструментарий busybox и реализацию библиотеки C musl. В итоге, вес образа меньше. Например, node:hydrogen-alpine3.18 весит 50.77 MB. Кроме того, в нём находят меньше уязвимостей безопасности. Например, одну.
Но образы node на основе Alpine выходят с некоторой задержкой. Мне не далось найти образ node:alpine, версии 20.х. Только 18.х.
## Устанавливайте только prod зависимости в образ Docker Node.js.
Следующая инструкция Dockerfile устанавливает все зависимости в контейнере, включая dev зависимости, которые нужны для разработки, но не нужны для работы в проде. Это добавляет лишние угрозы безопасности из-за пакетов, используемых в качестве зависимостей для разработки, а также увеличивает размер образа.

`RUN npm install`

В случае создания образа Docker для прода мы хотим убедиться, что мы устанавливаем только рабочие зависимости. Тогда лучше использовать команду.

`RUN npm ci --only=production`

## Оптимизируйте инструменты Node.js для prod.
Когда вы создаете свой образ Node.js для прода, вы хотите убедиться, что все платформы и библиотеки используют оптимальные настройки для производительности и безопасности.
Тогда нужно использовать такую инструкцию

`ENV NODE_ENV production`

На первый взгляд это выглядит избыточным, так как мы уже указали только прод зависимости на этапе установки npm. Однако эта переменная также имеет другие эффекты, о которых нам необходимо знать.

Некоторые фреймворки и библиотеки могут включать только оптимизированную конфигурацию, подходящую для прод среды, если эта переменная NODE_ENV установлена в значение production.
Например, в документации Express подчеркивается важность установки этой переменной среды для обеспечения оптимизации, связанной с производительностью и безопасностью:

Влияние переменной NODE_ENV на производительность может быть очень значительным.
Разработчики из Dynatrace написали сообщение в блоге, в котором подробно описаны радикальные последствия исключения NODE_ENV в ваших приложениях Express. Многие другие библиотеки, на которые вы полагаетесь, также могут реагировать на эту переменную.

Обновленный Dockerfile теперь должен выглядеть следующим образом.

```dockerfile
FROM node:20.3.1-bookworm-slim
ENV NODE_ENV production
WORKDIR /usr/src/app
COPY . /usr/src/app
RUN npm ci --only=production
CMD "npm" "start"
```

## Не запускайте контейнеры от имени root
Принцип наименьших привилегий — это принцип безопасности с первых дней существования Unix.
Если злоумышленнику удастся скомпрометировать веб-приложение таким образом, что это позволит использовать эксплоит Command injection или Directory traversal, то он получит привилегии пользователя, которому принадлежит процесс приложения. Если это пользователь root, то злоумышленник сможет делать практически все в контейнере, включая попытки выхода из контейнера или повышения привилегий . Зачем нам рисковать?

Официальный образ node, а также его варианты, такие как alpine, включают пользователя с наименьшими привилегиями с тем же именем: node. Однако недостаточно просто запустить процесс как node. Следующий вариант не достаточно хорош.

`USER node`

`CMD "npm" "start"`

Причина этого в том, что инструкция USER только гарантирует, что процесс принадлежит пользователю узла. А как насчет всех файлов, которые мы скопировали ранее с помощью инструкции COPY? Они принадлежат пользователю root. Так Docker работает по умолчанию.
Полный и правильный способ ограничения привилегий выглядит следующим образом, также демонстрируя наши последние практики Dockerfile на данный момент:

```dockerfile
FROM node:16.17.0-bullseye-slim
ENV NODE_ENV production
WORKDIR /usr/src/app
COPY --chown=node:node . /usr/src/app
RUN npm ci --only=production
USER node
CMD "npm" "start"
```

## Безопасно завершайте веб-приложения Node.js в контейнере
Одна из самых распространенных ошибок при создании Докерфайла, — это то, как запускается процесс. Все перечисленные ниже и их варианты являются плохими паттернами, которых следует избегать:

`CMD “npm” “start”`

`CMD [“yarn”, “start”]`

`CMD “node” “server.js”`

`CMD “start-app.sh”`

Давайте углубимся в эту тему. Рассмотрим каждый из ошибочных способов запуска и разберёмся, почему их следует избегать.
Следующие проблемы являются ключевыми для понимания контекста для правильного запуска и завершения приложений Node.js в контейнере Docker:
Механизму оркестрации, такому как Docker Swarm, Kubernetes или даже самому Docker, нужен способ отправки сигналов процессу в контейнере. В основном это сигналы для завершения приложения, такие как SIGTERM и SIGKILL.
Процесс может быть запущен косвенно, и если это произойдет, то не всегда гарантируется, что он получит эти сигналы.
Ядро Linux обрабатывает процессы с идентификатором процесса 1 (PID) иначе, чем с любым другим идентификатором процесса. В контейнере только один процесс имеет PID 1.
Вооружившись этими знаниями, давайте начнем исследовать способы вызова процесса для контейнера, начав с примера из Dockerfile, который мы создаем:

`CMD "npm" "start"`

## Использование execform
Предостережение здесь двоякое. Во-первых, мы напрямую вызываем клиент npm, но косвенно запускаем наше приложение. Нет гарантии, что интерфейс командной строки npm перенаправляет все сигналы в среду выполнения Node. На самом деле уже проверили, что не передаёт.
Другое предостережение связано с различными способами указания директивы CMD в Dockerfile. Есть два пути, и они не одинаковы:
- Вариант shellform. Выглядит так CMD "npm" "start". В этом случае контейнер создаёт интерпретатор оболочки, внутри которого запускается ваше приложение. В таких случаях оболочка может неправильно пересылать сигналы вашему процессу.
- Вариант execform. Выглядит так CMD ["npm", "start"]. Здесь напрямую создаётся процесс вашего приложения. Он не помещается в оболочку shell. Любые сигналы, отправленные в контейнер, напрямую отправляются в процесс.

Теперь мы можем улучшить нашу инструкцию для запуска процесса Dockerfile следующим образом:
CMD ["node", "server.js"]

Теперь мы вызываем процесс узла напрямую, гарантируя, что он получает все отправленные ему сигналы. Однако появляется другая проблема.

## Использование dumb-init

Когда процессы запускаются как PID 1, они фактически берут на себя некоторые обязанности системы инициализации, которая обычно отвечает за инициализацию операционной системы и процессов. Ядро обрабатывает PID 1 иначе, чем другие идентификаторы процессов. Это означает, что обработка сигнала SIGTERM для запущенного процесса не вызовет поведения по умолчанию, то есть уничтожения процесса, если, конечно, вы не написали свой обработчик.
Процитируем рекомендацию рабочей группы Node.js Docker по этому поводу: «Node.js не предназначен для работы с PID 1. Запуск с PID 1 приводит к неожиданному поведению при работе внутри контейнера Docker. Например, процесс Node.js, запущенный как PID 1, не будет отвечать на SIGINT (CTRL-C) и подобные сигналы».
Тогда способ сделать это — использовать инструмент, который будет действовать как процесс инициализации, в том смысле, что он вызывается с PID 1, а затем порождает наше приложение Node.js как другой процесс, обеспечивая при этом, чтобы все сигналы передавались этому node.js-процессу. Если возможно, мы хотели бы использовать как можно меньше инструментов для этого, чтобы не рисковать добавлением уязвимостей безопасности в наш образ контейнера.
Один из таких инструментов - это dumb-init, потому что он на зависит от сторонних библиотек и занимает мало места. Вот как это можно сделать.

`RUN apt-get update && apt-get install -y dumb-init`

`CMD ["dumb-init", "node", "server.js"]`

Тогда Dockerfile станет таким. Можно заметить, что мы разместили установку пакета dump-init сразу после объявления образа, чтобы мы могли воспользоваться преимуществами кэширования слоев Docker. Также мы добавили --no-install-recommends, чтобы не оставлять в образе лишних файлов.

```dockerfile
FROM node:16.17.0-bullseye-slim
RUN apt-get update && apt-get install -y --no-install-recommends dumb-init
ENV NODE_ENV production
WORKDIR /usr/src/app
COPY --chown=node:node . .
RUN npm ci --only=production
USER node
CMD ["dumb-init", "node", "server.js"]
```

Когда мы используем `apt-get update && apt-get install`, то оставляем лишние файлы в образе. Лучший способ исключить такие файлы - использовать многоэтапную сборку. Лучше установить инструмент dumb-init на первом этапе сборки, а затем скопировать полученный файл /usr/bin/dumb-init в окончательный образ, чтобы сохранить этот образ в чистоте.

## Используйте многоэтапную сборку

Многоэтапные сборки — отличный способ уменьшить объём образа Docker, уменьшить количество уязвимостей в нём и даже защититься от утечки паролей и токенов. Кроме того, мы также можем использовать большой базовый образ Docker для установки наших зависимостей, компилировать любые пакеты npm, если это необходимо, а затем копировать все эти артефакты в небольшой рабочий базовый образ.

- Предотвратить утечку конфиденциальной информации

Утечка конфиденциальной информации через образы Docker, более распространена, чем вы думаете.
Если вы создаете образы Docker, велика вероятность, что вы также создаёте приватные пакеты npm. Если это так, то вам, вероятно, нужно было найти способ сделать секретный NPM_TOKEN доступным для установки npm.
Вот пример, как это можно сделать.

```dockerfile
FROM node:16.17.0-bullseye-slim
RUN apt-get update && apt-get install -y --no-install-recommends dumb-init
ENV NODE_ENV production
ENV NPM_TOKEN 1234
WORKDIR /usr/src/app
COPY --chown=node:node . .
RUN echo "//registry.npmjs.org/:_authToken=$NPM_TOKEN" > .npmrc && \
         npm ci --only=production
USER node
CMD ["dumb-init", "node", "server.js"]
```

Однако при этом файл .npmrc с секретным токеном npm остается внутри образа Docker. Вы можете попытаться исправить это, удалив его впоследствии, например:

...

`RUN echo "//registry.npmjs.org/:_authToken=$NPM_TOKEN" > .npmrc && \
       npm ci --only=production; \
       rm -rf .npmrc`

Но теперь проблема заключается в том, что сам Dockerfile нужно рассматривать как секретный ресурс, потому что он содержит секретный токен npm внутри него.
К счастью, Docker поддерживает способ передачи аргументов в процесс сборки:

...

`ARG NPM_TOKEN`

`RUN echo "//registry.npmjs.org/:_authToken=$NPM_TOKEN" > .npmrc && \
       npm ci --only=production; \
       rm -rf .npmrc`

И тогда мы запускаем сборку следующим образом:

`$ docker build . -t nodejs-tutorial --build-arg NPM_TOKEN=1234`

Я знаю, вы думали, что на этом мы закончили с безопасностью, но извините, что разочаровал. Такие дела с безопасностью — иногда очевидные вещи оказываются очередной ловушкой.
В чем проблема теперь? Аргументы сборки, переданные таким образом в Docker, сохраняются в журнале. Давайте посмотрим своими глазами. Запустим эту команду:

`$ docker history nodejs-tutorial`

> IMAGE          CREATED              CREATED BY
> 
> ...
>
> <missing>      About a minute ago   RUN |1 NPM_TOKEN=1234 ...

Секретный токен npm оказался у всех на виду. Но существует отличный способ управления секретами для образа контейнера, но сейчас самое время представить многоэтапные сборки в качестве решения этой проблемы.

## Многоэтапная сборка образов Node.js Docker

У нас будет один образ, который мы используем для всего, что нам нужно для запуска приложения Node.js: установка пакетов npm и, при необходимости, компиляция собственных модулей npm. Это будет наш первый этап в первом образе Docker.

Второй образ Docker - второй этап сборки - будет рабочим. В результате второго этапа мы получим образ, который фактически опубликуем в реестре, если он у нас есть. А первый образ, который мы будем называть образом сборки, отбрасывается и остается висеть на хосте Docker, который его создал, до тех пор, пока он не будет очищен.

Вот обновление нашего Dockerfile. Новые строки подсвечены красным
```dockerfile
# The build image
FROM node:latest AS build
RUN apt-get update && apt-get install -y --no-install-recommends dumb-init
ARG NPM_TOKEN
WORKDIR /usr/src/app
COPY package*.json /usr/src/app/
RUN echo "//registry.npmjs.org/:_authToken=$NPM_TOKEN" > .npmrc && \
          npm ci --only=production && \
          rm -f .npmrc

# The production image
FROM node:20.3.1-bookworm-slim
ENV NODE_ENV production
COPY --from=build /usr/bin/dumb-init /usr/bin/dumb-init
USER node
WORKDIR /usr/src/app
COPY --chown=node:node --from=build /usr/src/app/node_modules /usr/src/app/node_modules
COPY --chown=node:node . /usr/src/app
CMD ["dumb-init", "node", "server.js"]
```

Как видите, я выбрал образ большего размера для этапа сборки, потому что мне могут понадобиться такие инструменты, как gcc (коллекция компиляторов GNU), для компиляции собственных пакетов npm или для других нужд.

На втором этапе существует специальный флаг `--from=build`, который означает, что файлы нужно копировать из другой стадии сборки.

Кроме того, теперь вы видите, что NPM_TOKEN не передается в качестве аргумента сборки финальному образу Docker. Он больше не отображается в выводе команды `docker history`, потому что он не существует в нашем итоговом образе докера.

## Исключите ненужные файлы при помощи .dockerignore
У вас есть файл .gitignore, чтобы не засорять репозиторий git ненужными файлами, а также потенциально конфиденциальными файлами, верно? То же самое относится и к образам Docker.

У Docker есть файл .dockerignore, который гарантирует, что при сборке будут пропущены все файлы, имена которых содержатся в списке внутри .dockerignore. Вот список файлов, которые мы не хотели бы помещать в наш образ: `.dockerignore, node_modules, npm-debug.log, Dockerfile, .git, .gitignore`

Папку node_modules/ на самом деле очень важно пропустить, так как в ней находятся файлы модулей, которые могли быть изменены с предыдущей сборки. Мы помещаем в образ новые файлы, значит мы не можем использовать кеш. В результате сборка идёт медленно. Также нужно проигнорировать логи и файлы конфигурации.

Ещё при использовании .dockerignore мы можем безопасно хранить секреты, такие как учетные данные в содержимом файлов .env или aws.json.

## Заключение

Мы сделали все возможное, чтобы создать оптимизированный наш образ Node.js Docker. Отличная работа!
Мы научились оптимизировать образы с точки зрения размера, безопасности. И наши секреты теперь хранятся конфиденциально. Мы готовы создавать образы, готовые к prod среде.