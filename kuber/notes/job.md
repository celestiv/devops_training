# Job

До этого момента мы концентрировались на том, что создавали приложения, которые   развёртываются    на    потенциально    бесконечное    время    жизни и Kubernetes следит за тем, чтобы они сохраняли свою доступность. Это очень актуально для Online задач. Но есть другой класс задач, решаемый с помощью Kubernetes. Это так называемые “Пакетные задачи” или батчи. Они представляют из себя Offline задачи и решаются без обеспечения прямого доступа пользователей к работающим в их рамках приложениям. Причём этот класс довольно широк, но часто относится к задачам организации процесса разработки и обслуживания систем - запуски конвейеров CI/CD, регулярной очистки и бэкапирования баз данных, создания очередей в брокерах сообщений и так далее. Для этих целей использование долгоживущих подов плохо подходит – во-первых, из-за характера задач, во-вторых, из-за невозможности отслеживания статуса их выполнения. Поэтому в Kubernetes реализован соответствующий контроллер репликации, который позволяет решать данный класс задач. Он называется Job и позволяет создавать поды с конечным сроком жизни, отслеживать статус их завершения и при необходимости автоматически перезапускать упавшие задачи. Покажем его работу, создав манифест с Job. Пусть он просто вычисляет число пи.

`$ nano job.yaml`

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: batch-job
spec:
  template:
    metadata:
      labels:
        app: batch-job
    spec:
      restartPolicy: OnFailure
      containers:
      - name: main
        image: perl:5.34.0
        command: ["perl", "-Mbignum=bpi", "-wle", "print bpi(2000)"]
```

При этом была создана задача. Поскольку мы оставили настройки по умолчанию она выполнится один раз, а в случае неудачи будет перезапущена. То есть создастся под, внутри него создастся описанный набор контейнеров и будет ожидаться, что все они завершатся с успешным кодом завершения (0). 

После этого задача будет считаться завершённой и под заново запускаться не будет. Если этого не случится, то контейнер будет перезапущен

Видим, что Job долго работал, но в конце завершился успешно. Число пи он вывел в логи.
В ряде случаев задачу требуется запустить несколько раз подряд. Kubernetes также предоставляет такую возможность, предлагая указать ожидаемое количество успешных завершений при задании её манифеста.

Продемонстрируем это, создав описание задачи с множественным запуском:

`nano job-multi-completion.yaml`

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: batch-job
spec:
  completions: 5
  template:
    metadata:
      labels:
        app: batch-job
    spec:
      restartPolicy: OnFailure
      containers:
      - name: main
        image: perl:5.34.0
        command: ["perl", "-Mbignum=bpi", "-wle", "print bpi(2000)"]
```

При этом будет создана новая задача, которая ожидает 5 успешных запусков. Поскольку не указано выполнять данные задачи в параллель, то задача будет запускаться 5 раз последовательно

`kubectl get po`

```shell
NAME                          READY   STATUS             RESTARTS        AGE
batch-job-6vc9q               1/1     Running            0               1s
batch-job-g769c               0/1     Completed          0               25s
batch-job-jtg54               0/1     Completed          0               16s
batch-job-lh4bx               0/1     Completed          0               9s
batch-job-tvjdg               0/1     Completed          0               33s
```

Как было сказано выше, для задач также может быть задан режим параллельного выполнения. В этом случае задача также будет выполнять столько раз, сколько указано в манифесте, но не последовательно, а по нескольку экземпляров за раз в зависимости от заданной степени параллелизма. Продемонстрируем это, создав описание задачи с множественным запуском и параллельным выполнением:

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: batch-job
spec:
  completions: 5
  parallelism: 2
  template:
    metadata:
      labels:
          app: batch-job
    spec:
      restartPolicy: OnFailure
      containers:
      - name: main
        image: perl:5.34.0
        command: ["perl", "-Mbignum=bpi", "-wle", "print bpi(2000)"]
  backoffLimit: 4
```

После запуска проверяем несколько раз состояние запущенных подов и видим что они создаются и запускаются по 2 за раз

`kubectl get po`

```shell
NAME                          READY   STATUS             RESTARTS        AGE
batch-job-586zx               0/1     Completed          0               10s
batch-job-7l5ht               0/1     Completed          0               10s
batch-job-fnxps               0/1     Completed          0               18s
batch-job-snkbv               1/1     Running            0               1s
batch-job-whgkh               0/1     Completed          0               18s
```

Если для контроля успешности работы приложения в Kubernetes используются проверки готовности и живости, то для задач такой подход плохо применим, поскольку как правило задачи не выставляют сокет и могут не создавать файлов (или создавать разные) внутри файловой системы контейнера. Но кое-что мы можем проконтролировать - с помощью соответствующих полей в манифесте мы можем задать время, за которое считаем, что задача должна быть выполнена (чтобы она не могла подвиснуть и застрять навечно в рабочем состоянии). Также мы можем указать ограничение на количество неуспешных завершений задачи чтобы она не вошла в бесконечный цикл повторения неудачных запусков. Продемонстрируем это, создав манифест задачи с ограничением на длительность выполнения и количество неудачных запусков:

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: batch-job
spec:
  completions: 5
  parallelism: 2
  backoffLimit: 3
  activeDeadlineSeconds: 10
  template:
    metadata:
      labels:
          app: batch-job
    spec:
      restartPolicy: OnFailure
      containers:
      - name: main
        image: perl:5.34.0
        command: ["perl", "-Mbignum=bpi", "-wle", "print bpi(2000)"]
  backoffLimit: 4
```

Теперь смотрим на состояние подов

`kubectl get po`

```shell
NAME                          READY   STATUS             RESTARTS        AGE
batch-job-kbcfj               0/1     Completed          0               102s
batch-job-s5xww               0/1     Completed          0               102s
```

`kubectl get jobs`

```shell
batch-job   Failed   2/5           99s        99s
```

Итак, мы поняли, что Job - это такой контроллер репликации, который запускает задачу только один раз (или нужное количество раз). Он отслеживает, успешно ли выполнилась работа, может запускать несколько задач параллельно и ограничивать время их выполнения
