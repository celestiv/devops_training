# ClickHouse

ClickHouse — это высокопроизводительная колоночная система управления базами данных SQL (СУБД) для оперативной аналитической обработки (online analytical processing, OLAP).
ClickHouse имеет Open Source реализацию, поэтому мы сможем попрактиковаться работать с ней.

- Что такое OLAP?

Сценарии OLAP требуют ответов в реальном времени с большими наборами данных для сложных аналитических запросов со следующими характеристиками:
Наборы данных могут быть огромными — миллиарды или триллионы строк.
Данные организованы в виде таблиц, содержащих множество столбцов.
Только несколько столбцов выбираются для ответа на любой конкретный запрос
Результаты должны быть возвращены за миллисекунды или секунды.
- Колоночные и строковые базы данных
В СУБД, ориентированной на строки, данные хранятся в строках, при этом все значения, относящиеся к строке, физически хранятся рядом друг с другом.
В СУБД, ориентированной на столбцы, данные хранятся в столбцах, а значения из одних и тех же столбцов хранятся вместе.
- Почему базы данных, ориентированные на столбцы, лучше работают в сценариях OLAP?
Базы данных, ориентированные на столбцы, лучше подходят для сценариев OLAP: они как минимум в 100 раз быстрее обрабатывают большинство запросов.

## Строковая СУБД
Нужно выбирать строку за строкой. Из каждой строки нужно выбрать нужные значения. После этого нужно обработать данные. На картинке ниже строковая база данных уже полностью закончила обработку трёх строк.

![Alt text](https://neostudy.neoflex.ru/pluginfile.php/138226/mod_scorm/content/11/res/data/islru-10138346/8528fbf5-fe50-11ee-81fd-a2346c2f09d9.png)

## Колоночная СУБД
Столбец считывается целиком. Данные сразу готовы к обработке. На картинке ниже колоночная база данных за то же время успела обработать весь запрос

![Alt text](https://neostudy.neoflex.ru/pluginfile.php/138226/mod_scorm/content/11/res/data/islru-10138346/bdc68187-fe50-11ee-9298-1e4c0d1886f9.png)

- Почему ClickHouse работает быстрее?

ClickHouse максимально использует все доступные системные ресурсы для максимально быстрой обработки каждого аналитического запроса.
Обработка аналитических запросов в режиме реального времени

В построчной СУБД данные хранятся в следующем порядке:

| Row | WatchID     | JavaEnable | Title              | GoodEvent | EventTime           |
|-----|-------------|------------|--------------------|-----------|---------------------|
| #0  | 89354350662 | 1          | Investor Relations | 1         | 2016-05-18 05:19:20 |
| #1  | 90329509958 | 0          | Contact us          | 1         | 2016-05-18 08:10:20 |
| #2  | 89953706054 | 1          | Mission             | 1         | 2016-05-18 07:38:00 |
| #N  | …           | …          | …                  | …         | …                   |

Другими словами, все значения, относящиеся к строке, физически хранятся рядом друг с другом. Примерами СУБД, ориентированной на строки, являются MySQL, Postgres и MS SQL Server.
В СУБД, ориентированной на столбцы, данные хранятся следующим образом:

| Row | WatchID     | JavaEnable | Title              | GoodEvent | EventTime           |
|-----|-------------|------------|--------------------|-----------|---------------------|
| #0  | 89354350662 | 1          | Investor Relations | 1         | 2016-05-18 05:19:20 |
| #1  | 90329509958 | 0          | Contact us          | 1         | 2016-05-18 08:10:20 |
| #2  | 89953706054 | 1          | Mission             | 1         | 2016-05-18 07:38:00 |
| #N  | …           | …          | …                  | …         | …                   |

В этих примерах показан только порядок расположения данных. Значения из разных столбцов хранятся отдельно, а данные из одного столбца хранятся вместе. Примеры колоночных СУБД: Vertica, Paraccel (Actian Matrix и Amazon Redshift), Sybase IQ, Exasol, Infobright, InfiniDB, MonetDB (VectorWise и Actian Vector), LucidDB, SAP HANA, Google Dremel, Google PowerDrill, Druid ...

Различные порядки хранения данных лучше подходят для разных сценариев. Сценарий доступа к данным относится к тому, какие запросы выполняются, как часто и в какой пропорции; сколько данных считывается для каждого типа запроса — строк, столбцов и байтов; связь между чтением и обновлением данных; рабочий размер данных и то, как локально они используются;  используются  ли  транзакции  и  насколько  они изолированы;  требования  к  репликации  данных  и  логической целостности; требования к задержке и пропускной способности для каждого типа запроса и так далее.

Чем выше нагрузка на систему, тем важнее настроить систему так, чтобы она соответствовала требованиям сценария использования, и тем более тонкой становится эта настройка. Не существует системы, одинаково хорошо подходящей для существенно разных сценариев. Если система адаптируется к широкому набору сценариев, при высокой нагрузке система будет одинаково плохо обрабатывать все сценарии или будет работать хорошо только для одного или нескольких возможных сценариев.

## Ключевые свойства сценария OLTP

- Таблицы «широкие», что означает, что они содержат большое количество столбцов.

- Наборы данных большие, а запросы требуют высокой пропускной способности при обработке одного запроса (до миллиардов строк в секунду на сервер).

- Значения столбцов довольно малы: числа и короткие строки (например, 60 байтов на URL).

- Запросы извлекают большое количество строк, но только небольшое подмножество столбцов.

- Для простых запросов допустимы задержки около 50 мс.

- На запрос приходится одна большая таблица; все другие таблицы маленькие, кроме одной.

- Результат запроса значительно меньше исходных данных. Другими словами, данные фильтруются или агрегируются, поэтому результат умещается в оперативной памяти одного сервера.

- Запросы относительно редки (обычно сотни запросов на сервер или меньше в секунду).

- Вставки происходят довольно большими партиями ( > 1000 строк), а не отдельными строками.

- Транзакции не нужны.

Легко заметить, что сценарий OLAP сильно отличается от других популярных сценариев (таких как доступ по ключу-значению). Так что нет смысла пытаться использовать Key-Value базу данных для обработки аналитических запросов, если вы хотите получить высокую производительность. Например, если вы попытаетесь использовать MongoDB или Redis для аналитики, вы получите очень низкую производительность по сравнению с базами данных OLAP.

## Операции ввода/вывода

Для аналитического запроса необходимо прочитать лишь небольшое количество столбцов таблицы. В базе данных, ориентированной на столбцы, вы можете считывать только те данные, которые вам нужны. Например, если вам нужно 5 столбцов из 100, вы можете ожидать 20-кратного сокращения операций ввода-вывода.

Поскольку данные считываются пакетами, их легче сжимать. Данные в столбцах также легче сжимать. Это еще больше уменьшает объем ввода- вывода.
Из-за сокращения операций ввода-вывода в системный кеш помещается больше данных.

Например, запрос «подсчитать количество записей для каждой рекламной площадки» требует чтения одного столбца «идентификатор рекламной площадки», который в несжатом виде занимает 1 байт. Если большая часть трафика была не с рекламных площадок, можно ожидать как минимум 10-кратное сжатие этой колонки. При использовании алгоритма быстрого сжатия возможна распаковка данных со скоростью не менее нескольких гигабайт несжатых данных в секунду. Другими словами, этот запрос может обрабатываться со скоростью примерно несколько миллиардов строк в секунду на одном сервере. Эта скорость реально достигается на практике.

## Процессор

Есть две возможности оптимизировать операции с большим количеством строк:
- Векторный процессор (Vector Engine Processor). Все операции пишутся для векторов, а не для отдельных значений. Это означает, что вам не нужно вызывать операции очень часто, а затраты на переключение незначительны.
- Генерация кода. Код, сгенерированный для запроса, содержит все косвенные вызовы.

Это не делается в базах данных, ориентированных на строки, потому что это не имеет смысла при выполнении простых запросов. Однако есть исключения. Например, MemSQL использует генерацию кода для уменьшения задержки при обработке SQL-запросов.

## Заключение

Итак, колоночные базы данных очень хороши для некоторых сценариев применения. Их часто применяют для быстрых аналитических запросов к большим наборам данных.