# Java + Docker
Java - один из очень популярных компилируемых языков программирования. Рассмотрим best practices при сборке образов с Java приложениями.

## Java до 8u121 не знала про ограничения cgroups

Если у вас устаревший код, то нужно знать, что старое java приложение могло запросто употребить все доступные ресурсы, невзирая на лимиты контейнера.
Но актуальные версии Java всё это умеют, поэтому лимиты контейнеру устанавливать можно и нужно. Для этого есть механизмы самой Java и механизмы Докера.

## Для сборки - Maven, для запуска – openjdk (или Zulu)

Образы для Java приложений обычно собираются в две стадии. На первой происходит компиляция при помощи Maven. На второй - запуск, обычно при помощи openjdk или Zulu. Не рекомендуется держать в одном образе инструменты для сборки и запуска.

## Подключайте тома для переиспользования кэша сборок

При сборке приложения на Maven с нуля будут скачиваться все зависимости. Это занимает очень много времени.
Но Maven умеет брать зависимости из кеша. Только этот кеш нужно где-то хранить между сборками. Для этого можно использовать Docker Volume.

## Ограничивайте размер кучи

Для Java размер кучи - это размер оперативной памяти, доступной для приложения. Этот размер кучи нужно ограничивать, чтобы приложение не съело всю память. Для этого есть параметры -Xmx и -XX:MaxRAMPercentage.
Но контейнеру нужно выделять на 25% больше памяти. Такова рекомендация из опыта. Дополнительная память потребуется на системные нужды контейнера.

## Пример Java Dockerfile

```dockerfile
# Первый шаг сборки

FROM maven:3.6-jdk-8-alpine AS builder

ARG USER_HOME_DIR="/root”
VOLUME "$USER_HOME_DIR/.m2”
ENV MAVEN_CONFIG "$USER_HOME_DIR/.m2"
WORKDIR /app

# Копируем зависимости и устанавливаем их
COPY pom.xml .
RUN mvn –e –B dependency:resolve

# Сборка jar-файла
COPY src ./src
RUN mvn –e –B package

# Второй шаг, копирование приложения и его запуск
FROM openjdk:8-jre-alpine
COPY --from=builder /app/target/app.jar /
CMD [“java”, “-jar”, “/app.jar”]
```

`FROM maven:3.6-jdk-8-alpine AS builder`

...

`FROM openjdk:8-jre-alpine`

Здесь снова двухэтапная сборка, так как мы видим дважды инструкцию FROM.

`VOLUME "$USER_HOME_DIR/.m2”`

`ENV MAVEN_CONFIG "$USER_HOME_DIR/.m2"`

Здесь мы подключаем том с кешем зависимостей.

`COPY pom.xml .`

`RUN mvn –e –B dependency:resolve`

Устанавливаем зависимости отдельным шагом, чтобы по максимуму использовать кеш.

`COPY src ./src`

`RUN mvn –e –B package`

Здесь запускаем сборку.

`FROM openjdk:8-jre-alpine`

`COPY --from=builder /app/target/app.jar /`

Здесь начинаем второй этап сборки и копируем в него только скомпилированное приложение.

## Разница между ARG и ENV

Заметим, что у нас есть две похожие инструкции: ARG и ENV.
ARG используется только для сборки и не попадает в итоговый контейнер.
ENV станет переменной окружения в запущенном контейнере.