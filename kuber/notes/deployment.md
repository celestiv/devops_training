# Deployment

ReplicaSet отлично выполняет возложенную на него задачу, но плохо подходит для развёртывания приложений при реальной эксплуатации, поскольку не отслеживает изменения в шаблоне описанного в нём пода. Другими словами, если вдруг вам нужно что-то изменить в конфигурации этого пода, то вам собственноручно  придётся удалять все экземпляры подов, управляемые ReplicaSet. Каждый раз. При любом изменении. Поэтому как правило напрямую его не используют, а используют абстракцию более высокого уровня - Deployment. 

Его основное отличие в том, что с его помощью мы можем изменять шаблон конфигурации пода в его манифесте и быть уверенными, что внесённые нами изменения будут применены, а текущие поды обновлены. Для этого он как раз использует ReplicaSet - при любом изменении шаблона пода Deployment создаёт новый экземпляр ReplicaSet с соответствующим шаблоном пода и обеспечивает уменьшение количества реплик в старом ReplicaSet до нуля, а в новом увеличение до желаемого количества

Пример

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80
```

## Масштабирование
Одно из преимуществ контроллеров репликации в том, что заданное число реплик в любой момент можно изменить. Изменение может быть произведено руками либо с помощью соответствующих средств автоматизации, называющихся автоскелерами, которые отслеживают метрики работы приложения (утилизацию CPU или любую другую метрику, характеризующую загрузку приложения) и реагируют на их пороговые значения, создавая дополнительные поды или же убивая лишние. Но и без автоскелеров нам доступны функции по масштабированию развёрнутого приложения с помощью встроенных команд kubect

Меняем количество реплик на 5

`kubectl scale deployment kubeserve --replicas=5`

## Обновление
Помимо масштабирования количества реплик Deployment предоставляет возможности по контролю доступности создаваемых экземпляров приложения. С помощью опции minReadySeconds мы можем указать минимальное количество секунд, в течение которых вновь созданный под должен быть готов без сбоя какого-либо из его контейнеров, чтобы он считался доступным. На основе информации о доступности сервисы принимают решение о том, включать ли под в балансировку нагрузки. 

Установим количество секунд, после прохождения которых развёрнутый модуль будет считаться готовым к эксплуатации. В дальнейшем это пригодится нам для демонстрации процесса обновления приложения. Мы используем команду kubectl patch, чтобы изменить манифест деплоймента

` kubectl patch deployment kubeserve \
-p '{"spec": {"minReadySeconds": 10}}'`

Теперь можем перейти непосредственно к процессу обновления приложений. Как правило жизненный цикл приложений в Kubernetes подразумевает внесение изменений в шаблон пода, будь то изменение версии образа, добавление переменных окружения или же корректировка контекста безопасности. На каждое такое изменение (или группу изменений, внесённую в манифест) Deployment создаёт отдельную ревизию и соответствующий экземпляр ReplicaSet для неё.

Для демонстрации изменим версию образа контейнера на “quay.io/evgeniy_ovchintsev/kubeserve:v2”:

```bash
nano kubeserve-deployment.yaml
…
    containers:
    - image: quay.io/evgeniy_ovchintsev/kubeserve:v2
       name: main
```

Обновим Deployment, применив скорректированный манифест к  инстансу Kubernetes:

`$ kubectl apply -f kubeserve-deployment.yaml`

При этом будет создан новый экземпляр ReplicaSet и Deployment позаботится о том, чтобы старый экземпляр был смасштабирован до нуля, а новый до заданного количества подов. Это будет видно на составе ReplicaSet в пространстве имён:

`$ kubectl get replicasets`

При этом для пользователя обновление будет бесшовным с точки зрения доступности сервиса.

## Откат обновления
Итак, обновление с одной версии на другую прошло для пользователя безболезненно. Но что если в новой версии содержится дефект, препятствующий работе пользователей?

Давайте смоделируем ситуацию, в которой новая версия содержит ошибку в работе и возвращает невалидный ответ пользователю. Для этого обновим образ в Deployment до версии 3 “quay.io/evgeniy_ovchintsev/kubeserve:v3”, содержащей дефект:
```bash
$ kubectl set image deployment kubeserve \
main=quay.io/evgeniy_ovchintsev/kubeserve:v3

deployment.apps/kubeserve image updated
```

После этого мы увидим, что приложение обновится до новой версии и постепенно будет возвращаться всё больше неуспешных ответов

`$ kubectl rollout undo deployments kubeserve`

После выполнения этой операции Deployment обеспечит постепенное масштабирование версии с ошибкой до нуля, а предыдущей стабильной версии до желаемого значения. При этом число ошибок, получаемых пользователями, снизится до нуля.

Откат доступен не только до предыдущей версии - Kubernetes хранит историю развёртываний (глубина хранения может быть задана) и позволяет пользователю совершать откат до любой доступной

`$ kubectl rollout undo deployment kubeserve --to-revision=3`

## Остановка обновления

При необходимости мы можем вручную контролировать процесс развёртывания (об этом мы уже говорили выше). Для демонстрации этих возможностей остановим процесс развёртывания, который мы запустили. При этом приложение попадёт в промежуточное состояние, в котором часть его реплик будет одной версии, а часть другой

## Liveness & Readyness Probes
Базово Kubernetes не поддерживает канареечное развёртывание в полном объёме, но предоставляет достаточно полезные механизмы для контроля успешности развёртывания приложения. Они называются проверками готовности и живости (Liveness & Readyness Probes). Эти проверки позволяют указать Kubernetes, как проверить, что приложение успешно запустилось (это может быть HTTP запрос, проверка открытия TCP сокета или же наличия файла на файловой системе) и что оно не упало или зависло и всё ещё успешно работает (способы те же). Для этого в описание конфигурации контейнера добавляется соответствующая секция. При этом если под не пройдёт проверку готовности, то Kubernetes не будет помечать его готовым и включать в балансировку трафика.

Проверка живости работает аналогичным образом с той лишь разницей, что процесс происходит регулярно в процессе всей жизни пода.

`kubectl describe pod $(kubectl get pods | grep 0/1 | awk '{print $1}')`

## Заключение
Итак, мы поняли, что Deployment - это полезный контроллер развёртывания. Он умеет плавно обновлять и откатывать обновление приложения. Для своей работы он создаёт один или несколько ReplicaSet, которые отслеживают реплики разных версий приложения.
