# Python + Docker
## Точные версии пакетов везде
Одна из общих практик - указывать точные версии пакетов везде: в поле FROM, в requirements.txt. В питоне не только значительно отличаются версии 2 и 3. Об этом все знают. Но и у версий 3.8 и 3.6 имеют свои особенности. Если не указывать точную версию, которой ваше приложение точно работает, то можно столкнуться с трудноуловимыми ошибками.
## Дважды используем COPY
В первый раз делаем COPY requirements.txt и ставим зависимости. Во второй раз используем COPY для кода (либо работаем через bind mount).
## Переменная PYTHONUNBUFFERED: 1 для упрощения отладки
С этим параметром Питон перестаёт буферизировать вывод и начинает выдавать в терминал сразу всё, что происходит. Это полезно, так как позволяет видеть вывод приложения практически в реальном времени. И этим мы предотвращаем ситуацию, когда часть вывода застряла в буфере в момент падения приложения. Иначе этот вывод мы просто не увидим. Это упрощает отладку приложения.
## Миграция БД и запуск приложения – это разные операции
То есть, можно настроить переменную окружения через ENV и командовать приложению выполнять ту или иную работу при разных значениях этой переменной.
## Если нужен virtualenv
В Питоне используется virtualenv, чтобы создавать для приложения замкнутое окружение с определенными версиями библиотек. Но Докер делает то же самое. Поэтому, если нужно запускать контейнеры с разными версиями библиотек, то нужно делать это через инструкцию ENV. Например, можно копировать в образ разные requirements.txt в зависимости от значения переменной ENV.
## Памятка по gunicorn
Для запуска веб-приложений на Питоне используется веб-сервер gunicorn. Вот рекомендации по его использованию в контейнере.

● `gunicorn --worker-tmp-dir /dev/shm` – перенос tmp в RAM.
Таким образом можно ускорить работу gunicorn, разместив временные файлы в оперативной памяти.

● `gunicorn --workers=2 --threads=4 --worker-class=gthread` – несколько потоков
Это нужно, если возможны медленные ответы нашего приложения. Например, у нас запросы к базе данных не оптимизированы. Приложение отвечает медленно и не принимает новые запросы. Чтобы этого избежать, лучше сразу запустить второй поток, который будет обрабатывать остальные запросы, пока первый поток занят с базой.
И если один поток не отвечает, то Докер может подумать, что приложение пора перезапускать. Тогда медленный запрос никогда не отработает до конца.

● `gunicorn --log-file=- `- пишем логи в STDOUT/STDERR.
Докер настроен так, что сохраняет в свой лог всё, что пишется в стандартные потоки STDOUT/STDERR. Значит, используя эту опцию, мы перенаправим логи gunicorn в логи Докера, и они будут видны снаружи контейнера.

## Пример Dockerfile с двухступенчатой сборкой

```dockerfile
FROM python:3.8 AS builder

COPY requirements.txt .

# Устанавливаем зависимости в локальный каталог
# (например /root/.local)

RUN pip install --user -r requirements.txt

# Второй шаг, уже без имени

FROM python:3.8-slim

WORKDIR /code

# Копируем только зависимости из образа, полученного на первом шаге

COPY --from=builder /root/.local/bin /root/.local

COPY ./src .

# Устанавливаем переменные окружения

ENV PATH=/root/.local:$PATH

ENV PYTHONUNBUFFERED=1

CMD [ "python", "./server.py" ]
```

Здесь мы видим двухступенчатую сборку. Она используется очень часто.

`FROM python:3.8 AS builder`

Начинаем мы с образа python:3.8. Он достаточно объёмный, но содержит все необходимые инструменты. Этот первый FROM имеет имя BUILD.

`COPY requirements.txt .`

`RUN pip install --user -r requirements.txt`

На него мы устанавливаем зависимости через `RUN pip install`. Также мы используем флаг --user, так как нужно ставить зависимости от рута (то есть, с повышенными привилегиями).

`FROM python:3.8-slim`

Дальше идёт второй FROM из образа python:3.8-slim. Это уже легковесный образ, из которого вырезаны все лишние инструменты. Он уже на базе Alpine, то есть более легковесный.
То есть, мы начинаем сборку заново, но у нас есть доступ к файлам предыдущего образа. И из предыдущей сборки мы копируем зависимости   

`COPY --from=builder /root/.local/bin /root/.local.`

`ENV PATH=/root/.local:$PATH`

Наконец, мы устанавливаем нужные переменные окружения. В этой строчке мы делаем так, чтобы зависимости из папки /root/.local были доступны для приложения.

`CMD [ "python", "./server.py" ]`

Наконец, запускаем приложение